#version 460 core

struct Vertex {
	vec4 position;
	vec4 normal;
	vec4 color;
	vec4 texUV;
};

layout(std430, binding = 0) buffer Vertices {
    Vertex vertices[];
};

layout(std430, binding = 1) buffer CraterPositions{
    vec4 craterPositions[];
};


//	<https://www.shadertoy.com/view/4dS3Wd>
//	By Morgan McGuire @morgan3d, http://graphicscodex.com
//
float hash(float n) { return fract(sin(n) * 1e4); }
float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }

float noise(float x) {
	float i = floor(x);
	float f = fract(x);
	float u = f * f * (3.0 - 2.0 * f);
	return mix(hash(i), hash(i + 1.0), u);
}

float noise(vec2 x) {
	vec2 i = floor(x);
	vec2 f = fract(x);

	// Four corners in 2D of a tile
	float a = hash(i);
	float b = hash(i + vec2(1.0, 0.0));
	float c = hash(i + vec2(0.0, 1.0));
	float d = hash(i + vec2(1.0, 1.0));

	// Simple 2D lerp using smoothstep envelope between the values.
	// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),
	//			mix(c, d, smoothstep(0.0, 1.0, f.x)),
	//			smoothstep(0.0, 1.0, f.y)));

	// Same code, with the clamps in smoothstep and common subexpressions
	// optimized away.
	vec2 u = f * f * (3.0 - 2.0 * f);
	return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

// This one has non-ideal tiling properties that I'm still tuning
float noise(vec3 x) {
	const vec3 step = vec3(110, 241, 171);

	vec3 i = floor(x);
	vec3 f = fract(x);
 
	// For performance, compute the base input to a 1D hash from the integer part of the argument and the 
	// incremental change to the 1D based on the 3D -> 1D wrapping
    float n = dot(i, step);

	vec3 u = f * f * (3.0 - 2.0 * f);
	return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),
                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),
                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
}


// exponential
float smin( float a, float b, float k )
{
    k *= 1.0;
    float r = exp2(-a/k) + exp2(-b/k);
    return -k*log2(r);
}


// Crater
uniform int numCraters;
uniform float craterSize;
uniform float craterWidth;
uniform float craterSteepness;
uniform float craterDepth;

// Crater Rim
uniform float rimSteepness;
uniform float rimWidth;
uniform float smoothingK;
uniform int rimExp;

// Noise
uniform vec3 noiseCentre;
uniform float noiseStrength;
uniform float noiseHeightShift;
uniform float noiseBaseFrequency;
uniform int noiseLayers;

float CraterHeight(float x) {
	float result = 0.0f;
	

	float craterConcave = (craterSteepness * x * x) - (craterSteepness * craterWidth * craterWidth);
	craterConcave = smin(craterConcave, craterDepth, -smoothingK);

	float rim = (rimSteepness * pow(abs(x), -1.0f)) - rimSteepness * pow((rimWidth + craterWidth), -1.0f);
	rim = smin(rim, 0.0f, -smoothingK);


	result = smin(craterConcave, rim, smoothingK);
	return result;
}



uniform float radius;
uniform float oceanRadius;
uniform int numVerts;
uniform int resolution;


void main() {
    uint idx = gl_GlobalInvocationID.x;
    uint idy = gl_GlobalInvocationID.y;
    uint idz = gl_GlobalInvocationID.z;

    uint currentVert = (idx * (resolution + 1) + idy) + ( ((resolution + 1) * (resolution + 1)) * idz);
  
    if (currentVert > numVerts) { return; }

	float MaxCraterDistance = craterWidth * 2;

	Vertex vert = vertices[currentVert];
	vert.position = vertices[currentVert].normal * radius;


	for(int i = 0; i < numCraters; i++){
		float dist = distance(vec3(vert.position), vec3(craterPositions[i]) * radius);
		if(dist < MaxCraterDistance){
			vert.position += vert.normal * CraterHeight(dist);
		}
	}
	
	float noiseMul = 1.0;
	float noiseFreq = noiseBaseFrequency;
	float strength = noiseStrength;

	float noiseRemap = 0.0;

	for(int i = 0; i < noiseLayers; i++){
		noiseMul += noise((vec3(vert.position) + (noiseCentre * radius)) * noiseFreq) * strength;
		noiseFreq *= 1.5;
		noiseRemap += strength;
		strength *= 0.5;
	}

	noiseMul = (noiseMul + noiseHeightShift) - (noiseRemap / 2) - 1;

	vert.position += vert.normal * max(noiseMul, 0.0);



	vertices[currentVert] = vert;

}



struct Vertex {
	vec4 position;
	vec4 normal;
	vec4 color;
	vec4 texUV;
};

layout(std430, binding = 0) buffer Vertices {
    Vertex vertices[];
};






uniform int numVerts;
uniform int resolution;


void main() {
    uint idx = gl_GlobalInvocationID.x;
    uint idy = gl_GlobalInvocationID.y;
    uint idz = gl_GlobalInvocationID.z;

    uint i = (idx * (resolution + 1) + idy) + ( ((resolution + 1) * (resolution + 1)) * idz);
  
    if (i >= numVerts) { return; }
    Vertex vert = vertices[i];

    vec3 thisVert = vec3(vertices[i].position);
	vec3 lateralVert;
	vec3 medialVert;
	vec3 normal = vec3(1.0f);

	float invert = 1.0f;

	// Get Face
	int face;
	if (i <= ((resolution + 1) * (resolution + 1))) { face = 1; }
	else if (i <= 2 * ((resolution + 1) * (resolution + 1))) { face = 2; }
	else if (i <= 3 * ((resolution + 1) * (resolution + 1))) { face = 3; }
	else if (i <= 4 * ((resolution + 1) * (resolution + 1))) { face = 4; }
	else if (i <= 5 * ((resolution + 1) * (resolution + 1))) { face = 5; }
	else { face = 6; }

	float itsThisFace = face * ((resolution + 1) * (resolution + 1));
	// If the vertex is top or bottom
	if (i >= 4 * ((resolution + 1) * (resolution + 1))) {
	

		// if vert is not at end of the row lateral should be to the right
		if ((i + 1) % (resolution + 1) != 0.0f && (i + 1) <= numVerts && i + 1 <= itsThisFace) { lateralVert = vec3(vertices[i + 1].position); invert *= -1.0f;	}
		else {	lateralVert = vec3(vertices[i - 1].position);	}


		// if the up medial vert is still inside this face medial should be up a row
		if (i + resolution + 1 < numVerts && i + resolution + 1 <= itsThisFace) { medialVert = vec3(vertices[i + resolution + 1].position);	}
		else { medialVert = vec3(vertices[i - resolution - 1].position); invert *= -1.0f; }

		// If not on any of the above multiply invert "invert" 
		normal = invert * normalize(cross(lateralVert - thisVert, medialVert - thisVert));


	}
	else {


		// if vert is not at end of the row lateral should be to the right
		if ((i + 1) % (resolution + 1) != 0.0f  && i < itsThisFace) {	lateralVert = vec3(vertices[i + 1].position); invert *= -1.0f; }
		else {	lateralVert = vec3(vertices[i - 1].position);	}


		// if the up medial vert is still inside this face medial should be up a row
		if (i + resolution + 1 < itsThisFace) {	medialVert = vec3(vertices[i + resolution + 1].position);	}
		else {	medialVert = vec3(vertices[i - resolution - 1].position);	invert *= -1.0f;	}


		// If not on any of the above multiply invert "invert" 
		normal = invert * normalize(cross(lateralVert - thisVert, medialVert - thisVert));
	
	
	}
	
	vert.normal = vec4(normal, 1.0f);
	vert.color = vert.normal;
	vertices[i] = vert;

}